1. Що таке структурне програмування?
Структурне програмування - методологiя розробки програмного забезпечення на основi представлення програми у виглядi
iєрархiчної структури блокiв.

2. Основні конструкції структурного програмування:
Послідовність: Блоки коду виконуються один за одним у тому порядку, в якому вони записані.
Розгалуження: Залежно від умови виконується один з декількох блоків коду (if, else, switch).
Цикли: Блок коду повторюється до виконання певної умови (while, do-while, for).

3. Основні принципи структурного програмування:
Модульність: Розбиття програми на окремі модулі (функції, процедури), які виконують конкретні завдання.
Структурованість: Використання обмеженого набору контрольних структур.
Ієрархічність: Побудова програми за принципом зверху вниз, від загального до конкретного.
також відомий узагальнюючий принцип DRY (Don’t repeat yourself);
"Блоки"програми, якi повторюються слiд оформляти у виглядi
пiдпрограм (процедури, функцiї, методи)

4. Чому уникають оператора GOTO?
Оператор GOTO дозволяє переходити до довільної точки програми, що ускладнює розуміння і відлагодження коду. Структурне програмування пропонує більш зрозумілі та керовані конструкції для організації потоку виконання.

5. Спагеті-код
Спагеті-код – це код з великою кількістю переходів (наприклад, через оператор GOTO), що робить його важким для розуміння і підтримки. 

6. Проектування зверху-вниз
Проектування зверху-вниз передбачає розбиття задачі на підзадачі, потім кожну підзадачу – на ще дрібніші підзадачі і так далі, доки не будуть отримані прості завдання, які легко реалізувати. Це дозволяє краще структурувати програму і полегшує її розробку та тестування.

7. Область видимості ідентифікатора
Область видимості ідентифікатора – це частина програми, в якій цей ідентифікатор має визначене значення.

8. Блоки і область видимості
Блок – це група інструкцій, об'єднаних фігурними дужками. Змінні, оголошені всередині блоку, видимі тільки всередині цього блоку. Це дозволяє локалізувати змінні і уникнути конфліктів імен.

9. Вибір операторів розгалуження
if: Використовується для прийняття рішення на основі однієї умови.
if-else: Використовується для прийняття рішення на основі двох альтернатив.
ланцюги if-else if -else if...: Використовуються для прийняття рішення на основі декількох умов.
switch: Використовується для прийняття рішення на основі значення однієї змінної.
тернарна умовна операція ?:: Використовується для коротких умовних виразів.
10. Вибір циклів
while: Використовується, коли кількість ітерацій невідома заздалегідь.
public class WhileExample {
    public static void main(String[] args) {
        int i = 1;
        while (i <= 10) {
            System.out.println(i);
            i++;
        }
    }
}
do-while: Використовується, коли цикл має виконатися хоча б один раз.
public class SumEvenNumbersDoWhile {
    public static void main(String[] args) {
        int sum = 0;
        int i = 2;

        do {
            sum += i;
            i += 2;
        } while (i <= 100);

        System.out.println("Сума парних чисел від 1 до 100: " + sum);
    }
}
for: Використовується, коли кількість ітерацій відома заздалегідь.
public class OddNumbers {
    public static void main(String[] args) {
        for (int i = 1; i <= 20; System.out.println(i), i += 2);
    }
}
11. break і continue
break: Перериває виконання найближчого циклу.
continue: Переходить до наступної ітерації циклу, пропускаючи решту тіла циклу.
12. Мітки в Java
Мітки використовуються для позначення місця в коді, до якого можна перейти за допомогою оператора break або continue з вказаною міткою. Це дозволяє організувати більш складні структури керування потоком виконання.
13. До якого результату призведе виконання наступного фрагменту коду? Перевірте. Поясніть.

    boolean a = false;
    boolean b = false;
    if (a=false) {
    System.out.println("a is falset");
    }
    if (b=true) {
    System.out.println("b is true");
    }
    if (a=b) {
    System.out.println("a = b");
    }
Вивід:
b is true
a = b

Пояснення
Перший if-вираз:
Умова a=false насправді є присвоєнням, оскільки використовується оператор =. Це призводить до того, що змінній a присвоюється значення false, а потім повертається це ж значення.
Оскільки будь-яке присвоєння повертає присвоєне значення, а false вважається хибним, то блок if не виконується.

Другий if-вираз:
Умова b=true також є присвоєнням. Змінній b присвоюється значення true, і оскільки будь-яке ненульове значення вважається істинним, то блок if виконується, і на екран виводиться повідомлення "b is true".

Третій if-вираз:
Умова a=b знову є присвоєнням. Змінній a присвоюється значення змінної b, яке на цей момент дорівнює true. Оскільки будь-яке ненульове значення вважається істинним, то блок if виконується, і на екран виводиться повідомлення "a = b".

14. До якого результату призведе виконання наступного фрагменту коду? Перевірте. Поясніть.
int a = 1;
        a++;
        ++a;
        switch(a) {
            case 1: System.out.println("1");
            case 2: System.out.println("2");
            case 3: System.out.println("3");
            case 4: System.out.println("4");
        }
Вивід:
3
4
Пояснення:
ніціалізація змінної:
Змінна a отримує початкове значення 1.

Інкременти:
a++: Після використання значення a збільшується на 1. Тобто, після цього оператора a буде дорівнювати 2.
++a: Перед використанням значення a збільшується на 1. Тобто, після цього оператора a буде дорівнювати 3.

Конструкція switch:
switch(a): Починається блок switch, де значення змінної a порівнюється з кожним значенням case.
Оскільки a дорівнює 3, то виконується блок коду, що відповідає case 3, а потім, оскільки в кожному case відсутній оператор break, виконання продовжується до кінця блоку switch.

15. До якого результату призведе виконання наступного фрагменту коду? Перевірте. Поясніть.
double sum = 0;
        // Let's find: 1 + 1/2 + 1/3 + 1/4 + 1/5 + ...
        for(int i=1; i<10; i++) {
            sum = sum + 1/i; // Зверніть увагу на 1.0
        }
        System.out.println(sum>1);
Вивід: false

Пояснення:

при ініціалізації змінної sum ми вкзали що вона має тип double, проте при виконанні циклу
for(int i=1; i<10; i++) {
            sum = sum + 1/i;
        }
до її початкового значення 0 додається лише ціла частина результату частки  1/i, а отже лише 1 під час першого циклу, а всі наступні 8 разів буде додаватися лише 0, адже отримана частка виражається лише в цілих через те що int i=1, а сама одиниця (sum = sum + 1/i;) теж вказана в цілих, тому їх дробова частина не буде додаватися. 
