1. ### Чим змінна відрізняється від масиву?
Змінна: Представляє одне значення певного типу (int, double, String тощо). Вона займає фіксовану ділянку пам'яті.
Масив: Це впорядкована колекція елементів одного типу. Масив - це змінна, але вона містить кілька значень. Кожне значення в масиві має свій індекс, за яким до нього можна звернутися.
2. ### Що таке стек? Що таке купа? Яка між ними різниця?
Стек: Область пам'яті, де зберігаються локальні змінні, параметри методів та повертаємі значення. Стек працює за принципом LIFO (Last In, First Out) - останнім прийшов, першим пішов.
Купа: область пам'яті, яка використовується для динамічного виділення пам'яті під час виконання програми. На відміну від стеку, де розміщуються локальні змінні та параметри функцій, купа використовується для створення об'єктів, розмір яких невідомий наперед
3. ### Чи може змінна бути розташована у стеку? Безпосередньо у купі? В об’єкті у купі? Чи може масив бути розташований у стеку? Безпосередньо у купі? В об’єкті у купі?
## Змінна:
Стек: Локальні змінні, як правило, розміщуються в стеку.
Купа: Змінні, які є полями об'єктів, розміщуються в купі разом з самим об'єктом.
## Масив:
Купа: Масиви завжди розміщуються в купі, оскільки вони займають змінну кількість пам'яті.
Стек: Посилання на масив (тобто змінна, яка зберігає адресу початку масиву в пам'яті) може бути розміщено в стеку.
Об'єкт: Масив може бути полем об'єкта, тобто розміщуватися в купі разом з іншими полями цього об'єкта.
4. ### Чим посилання на масив відрізняється від масиву? Чи може посилання на масив бути розташовано у стеку? Безпосередньо у купі? В об’єкті у купі?
Посилання: Це змінна, яка зберігає адресу початку масиву в пам'яті. Сам масив розташований в купі, а посилання може бути розташоване як в стеку, так і в купі (як поле об'єкта).
Відмінності: Посилання вказує на масив, але не є самим масивом. Змінюючи елементи масиву через посилання, ми змінюємо сам масив.
5. ### Якщо масив складається з 10 комірок, які індекси мають перша та остання комірки?
Перша комірка має індекс 0.
Остання комірка має індекс 9.
6. ### Що буде, якщо звернутися до неіснуючої комірки у масиві?
Спричинить помилку виконання програми (ArrayIndexOutOfBoundsException).

7. ### При створенні нового масиву без явної ініціалізації усі його комірки будуть проініціалізовані:
- спеціальними значеннями за замовчуванням?
- довільними значеннями, що знаходяться в цей час у пам’яті, яку виділено під масив?

При створенні масиву без явної ініціалізації його елементи будуть проініціалізовані спеціальними значеннями за замовчуванням:

Для числових типів (int, double) - нулем.
Для булевих типів - false.
Для посилальних типів (об'єкти, рядки) - null.

8. ### Як дізнатися номер першої та останньої комірки масиву, якщо відомо лише посилання на нього?
Потрібно використати: (посилання на масив).length
Тоді щоб дізнатися номер останньої комірки, від довжини масиву віднімаємо 1. Номер першої комірки завжди 0.

9. ### Як змінити розмір масиву?
В Java розмір масиву фіксований після його створення. Щоб змінити розмір, потрібно створити новий масив і скопіювати в нього дані зі старого.

10. ### Що відбувається з масивом при копіюванні посилання на нього?
При копіюванні посилання на масив ми отримуємо нову змінну, яка вказує на той самий масив. Зміни, внесені через будь-яке з цих посилань, будуть відображені в обох.

11. ### Що відбувається з масивом при втрачанні посилання на нього?
Якщо всі посилання на масив втрачені, то цей масив стає недоступним для програми і підлягає видаленню з пам'яті через певний час.
12. ### Чим відрізняються конструкції «for» та «for-each» при роботі з масивами? Які переваги та недоліки кожного з варіантів?
## Цикл for:
Коли потрібно змінювати елементи масиву під час ітерації.
Коли потрібно працювати з індексами елементів.
Коли потрібно перебирати масив в нестандартному порядку.
## Цикл for-each:
Коли потрібно просто перебрати всі елементи масиву і виконати над ними однакові дії.
Коли важлива читабельність коду.
13. ## Чи можна у масив «double[]» записати значення «int»? Чи можна у масив «int[]» записати значення «double»?
double[] -> int[]: Не можна напряму, оскільки може призвести до втрати точності.
int[] -> double[]: Можна, але цілі числа будуть автоматично приведені до типу double.