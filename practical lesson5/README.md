## 1. Порівняння та переваги/недоліки методів сортування:

## Сортування бульбашкою (Bubble Sort):

Переваги: Простота реалізації; легко зрозуміти; стабільний алгоритм (зберігає порядок однакових елементів).
Недоліки: Низька ефективність при великих обсягах даних, навіть у найкращому випадку не дуже оптимізований.

## Сортування вибором (Selection Sort):

Переваги: Простота реалізації; не потребує додаткової пам'яті, оскільки є in-place алгоритмом.
Недоліки: Нестабільний алгоритм; часто менш ефективний, ніж сортування вставкою, оскільки навіть у найкращому випадку потребує однакову кількість порівнянь.

## Сортування вставкою (Insertion Sort):

Переваги: Швидкий для малих або частково відсортованих масивів; стабільний алгоритм; працює краще за сортування бульбашкою і вибором на частково відсортованих даних.

Недоліки: Не підходить для великих масивів, оскільки має квадратичну складність.
Оцінка за критеріями:

## 3. Час роботи:

####  Bubble Sort:
O(n²) у середньому і найгіршому випадках. У найкращому випадку O(n), коли масив вже відсортований.
#### Selection Sort: 
O(n²) у всіх випадках, оскільки проходить весь масив на кожній ітерації.
#### Insertion Sort: 
O(n²) у середньому і найгіршому випадках, але O(n) у найкращому випадку, коли масив частково відсортований.

Потреби у додатковій пам’яті:

Усі три алгоритми є in-place і не потребують додаткової пам’яті O(1), окрім декількох допоміжних змінних.

#### Стабільність:

Bubble Sort: стабільний.
Selection Sort: нестабільний (наприклад, змінює порядок однакових елементів).
Insertion Sort: стабільний.

#### Інші критерії для порівняння:

Адаптивність: Наскільки добре алгоритм працює на частково відсортованих масивах.
Чутливість до порядку елементів: Як алгоритм поводиться при обробці масивів, відсортованих у зворотному порядку.

## 3. Кращий/гірший випадки для кожного алгоритму:

### Bubble Sort:

Кращий випадок: Відсортований масив (O(n)), оскільки перевірка на місці дає можливість припинити роботу після одного проходу.
Гірший випадок: Масив, відсортований у зворотному порядку (O(n²)).

### Selection Sort:

Кращий і гірший випадки однакові: O(n²), оскільки алгоритм завжди робить однакову кількість порівнянь незалежно від початкового стану масиву.

### Insertion Sort:

Кращий випадок: Частково або повністю відсортований масив (O(n)), коли зсувів елементів не потрібно.
Гірший випадок: Масив, відсортований у зворотному порядку (O(n²)), оскільки кожен новий елемент зсуває всі попередні.

## 4. Позначення

Позначення O(n²), O(n), O(1) є нотацією O-велике (Big O notation), яка використовується для оцінки ефективності алгоритмів. Вона показує, як час виконання алгоритму або використання пам'яті змінюються зі збільшенням кількості елементів (розміром вхідних даних) — позначеного як n. Ця нотація допомагає оцінити алгоритми за їх асимптотичною складністю, тобто за тим, як вони працюють для дуже великих значень n.

Пояснення основних позначень

## O(1) — Постійна складність:

Означає, що час виконання алгоритму або використання пам'яті не залежать від розміру вхідних даних.
Наприклад, доступ до конкретного елемента масиву за індексом має складність O(1), оскільки для цього не потрібно проходити всі елементи масиву.
Це найбільш ефективний варіант з точки зору швидкодії.

## O(n) — Лінійна складність:

Означає, що час виконання або використання пам'яті зростає прямо пропорційно розміру вхідних даних.
Наприклад, простий прохід по всіх елементах масиву для їх підрахунку має складність O(n), оскільки кожен елемент потрібно обробити один раз.
Підходить для роботи з великими масивами, але вимагає, щоб алгоритм був оптимізований для уникнення зайвих обчислень.

## O(n²) — Квадратична складність:

Означає, що час виконання або використання пам'яті зростає пропорційно квадрату розміру вхідних даних.
Це часто трапляється в алгоритмах, які використовують вкладені цикли, наприклад, при порівнянні всіх елементів масиву з усіма іншими елементами (як у сортуванні бульбашкою чи вибором).
Така складність швидко стає неефективною для великих обсягів даних.