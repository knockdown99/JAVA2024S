# Java Collections Framework: FAQ

## 1. Для чого призначений Collections Framework?
Java Collections Framework (JCF) призначений для:
- **Управління колекціями даних**: надає стандартний набір інтерфейсів і класів для зберігання та маніпуляції даними (списки, множини, мапи тощо).
- **Спрощення роботи з даними**: забезпечує універсальні алгоритми для пошуку, сортування, вставки, видалення та інших операцій.
- **Уніфікації структури даних**: пропонує узгоджений API для роботи з різними типами колекцій, спрощуючи їх взаємодію.

---

## 2. В чому полягає різниця між масивами та колекціями?
| **Критерій**        | **Масиви**                                   | **Колекції**                                   |
|---------------------|---------------------------------------------|-----------------------------------------------|
| **Розмір**          | Фіксований під час створення.               | Динамічний, змінюється під час виконання.      |
| **Тип елементів**   | Однорідні елементи (один тип).              | Можуть бути однорідними або різнорідними.      |
| **Функціональність**| Простий API для доступу до елементів.       | Розширений API для вставки, видалення, пошуку. |
| **Продуктивність**  | Швидший доступ до елементів за індексом.    | Гнучкість для роботи зі складними структурами. |

---

## 3. Які особливі властивості є у списків порівняно з іншими типами колекцій?
- **Упорядкованість**: Елементи зберігаються у тому порядку, в якому додаються.
- **Доступ за індексом**: Можливість доступу до елементів за їх індексом.
- **Дублікати**: Списки дозволяють зберігати дублікати елементів.
- **Методи маніпуляції**: Включають операції для вставки, видалення або заміни елементів за індексом.

---

## 4. Чим списки відрізняються від масивів?
| **Критерій**            | **Масиви**                                   | **Списки (List)**                             |
|-------------------------|---------------------------------------------|-----------------------------------------------|
| **Розмір**              | Фіксований.                                | Динамічний.                                   |
| **Методи доступу**      | Прямий доступ до елементів через індекс.   | Методи `add()`, `remove()`, `get()` тощо.     |
| **Гнучкість**           | Не можуть змінювати розмір.                | Можуть автоматично змінювати розмір.          |
| **Тип**                | Підтримують примітивні типи.                | Працюють лише з об’єктами (обгортки для примітивів). |

---

## 5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?
| **Критерій**               | **ArrayList**                                | **LinkedList**                               |
|----------------------------|----------------------------------------------|---------------------------------------------|
| **Структура**              | Масив із динамічним розміром.               | Двонапрямний зв’язний список.               |
| **Швидкість доступу**      | Швидкий доступ за індексом (`O(1)`).         | Повільний доступ за індексом (`O(n)`).      |
| **Швидкість вставки/видалення** | Повільна для великих обсягів (`O(n)`).        | Швидка вставка/видалення (`O(1)` для голови або хвоста). |
| **Використання пам’яті**   | Менше, оскільки використовує масив.          | Більше через збереження посилань на сусідів. |

### Коли використовувати:
- **ArrayList**: Якщо потрібен швидкий доступ за індексом або часті операції читання.
- **LinkedList**: Якщо частіше виконується вставка/видалення елементів у середині списку.

---

## 6. Що таке Iterator? В чому полягають переваги використання ітератора у порівнянні з класичним циклом?
**Iterator** — це об'єкт, який дозволяє поетапно перебирати елементи колекції.

### Переваги ітератора:
1. **Абстракція**: Не потребує знання внутрішньої структури колекції.
2. **Безпека**: Забезпечує захист від помилок під час видалення елементів (через метод `remove()`).
3. **Гнучкість**: Підтримує різні типи колекцій (списки, множини тощо).

**Порівняння з циклом `for`:**
- Цикл `for(int i=0; i<collection.size(); i++)`:
  - Може спричинити помилки при модифікації колекції (наприклад, видалення елементів).
  - Залежить від прямого доступу до індексів.
- Ітератор:
  - Дозволяє безпечну модифікацію (видалення) під час ітерації.
  - Працює з усіма типами колекцій, навіть без індексів.

---

## 7. Що таке типізовані та нетипізовані колекції?
- **Типізовані колекції**:
  - Визначають тип елементів, які можуть зберігатися.
  - Використовують Generics (`List<String>`, `Set<Integer>` тощо).
  - Переваги:
    - Уникають помилок типу.
    - Забезпечують перевірку типів під час компіляції.

- **Нетипізовані колекції**:
  - Не обмежують тип елементів.
  - Використовувалися до появи Generics у Java 5.
  - Недоліки:
    - Викликають помилки типу під час виконання програми (`ClassCastException`).
    - Потребують явного приведення типів.

---

## 8. Для чого потрібен інтерфейс RandomAccess?
**RandomAccess** — маркерний інтерфейс, який вказує, що колекція забезпечує швидкий доступ до елементів за індексом.

### Основні моменти:
- Використовується класами, такими як `ArrayList`.
- Оптимізує алгоритми, які працюють із колекціями, наприклад, цикли.
- Колекції, які не реалізують `RandomAccess` (наприклад, `LinkedList`), краще ітерувати послідовно.

---

## 9. Чим Collection відрізняється від Collections?
| **Клас/Інтерфейс** | **Опис**                                                                            |
|--------------------|------------------------------------------------------------------------------------|
| **`Collection`**   | Інтерфейс, що визначає основні операції для всіх колекцій (списки, множини тощо).  |
| **`Collections`**  | Клас, який містить утилітарні методи для роботи з колекціями (наприклад, сортування, пошук). |

### Приклад використання `Collections`:
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(3, 1, 2));
Collections.sort(numbers); // Сортування списку
System.out.println(numbers); // Виведе: [1, 2, 3]
