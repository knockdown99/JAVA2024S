# Java Collections: `Set`, `HashSet`, `TreeSet` і Хешування

## 1. **Чим інтерфейс `Set` відрізняється від `Collection` та `List`?**

- **`Collection`**: Основний інтерфейс, що визначає базові операції для роботи з колекціями (`add`, `remove`, `size` тощо). `Set` та `List` є підінтерфейсами `Collection`.
  
- **`Set`**:
  - Не дозволяє дублювання елементів.
  - Не гарантує порядок елементів (крім реалізацій, таких як `LinkedHashSet` чи `TreeSet`).
  - Реалізації: `HashSet`, `TreeSet`, `LinkedHashSet`.

- **`List`**:
  - Дозволяє дублікати.
  - Зберігає порядок вставки елементів.
  - Реалізації: `ArrayList`, `LinkedList`, `Vector`.

---

## 2. **Чим `HashSet` відрізняється від `TreeSet`?**

| **Критерій**            | **HashSet**                       | **TreeSet**                      |
|-------------------------|-----------------------------------|-----------------------------------|
| **Порядок елементів**   | Не гарантує жодного порядку.      | Елементи зберігаються в порядку сортування. |
| **Реалізація**          | Використовує хеш-таблицю.         | Використовує дерево (Red-Black Tree).       |
| **Швидкість операцій**  | Операції `add`, `remove`, `contains` мають середню складність O(1). | Операції мають складність O(log n).         |
| **Вимоги до елементів** | Елементи повинні мати коректні `hashCode()` та `equals()`. | Елементи повинні бути `Comparable` або мати `Comparator`. |
| **Призначення**         | Коли потрібна швидкість і унікальність. | Коли потрібна упорядкованість. |

---

## 3. **Що таке хешування, хеш, хеш-код, хеш-функція?**

- **Хешування**: Процес перетворення даних у хеш (коротке числове або символьне представлення).
- **Хеш**: Значення, згенероване хеш-функцією (зазвичай цілочислове).
- **Хеш-код**: Результат виконання методу `hashCode()`, який представляє об'єкт у вигляді числового значення.
- **Хеш-функція**: Алгоритм, який генерує хеш-код для об'єкта. Використовується для швидкого доступу до даних у хеш-таблицях.

---

## 4. **Яким вимогам має відповідати коректна хеш-функція?**

1. Якщо два об'єкти рівні (`equals()` повертає `true`), їхні хеш-коди повинні збігатися.
2. Якщо два об'єкти не рівні, їхні хеш-коди можуть бути однаковими (але це не бажано).
3. Хеш-код має залишатися незмінним протягом існування об'єкта (якщо його поля не змінюються).

---

## 5. **Які властивості притаманні хорошій хеш-функції?**

1. **Однорідність розподілу:** Хеш-коди повинні рівномірно розподілятися по всіх можливих бакетах.
2. **Швидкість обчислення:** Хеш-код повинен обчислюватися швидко.
3. **Мінімізація колізій:** Уникнення ситуацій, коли різні об'єкти мають однаковий хеш-код.

---

## 6. **Якими критеріями мають відповідати об’єкти для зберігання в `HashSet`?**

1. **Реалізація `hashCode()` та `equals()`:**
   - `hashCode()` використовується для швидкого пошуку.
   - `equals()` використовується для перевірки рівності об'єктів.
2. **Коректність методів:**
   - Якщо два об'єкти рівні (`equals()` повертає `true`), їхні хеш-коди мають збігатися.
3. **Не змінюваність ключових полів:** Поля, які впливають на результат `hashCode()` та `equals()`, не повинні змінюватися, поки об'єкт знаходиться у `HashSet`.

---

## 7. **Переваги/недоліки використання `HashSet` порівняно з `TreeSet`**

| **Критерій**          | **HashSet**                       | **TreeSet**                      |
|-----------------------|-----------------------------------|-----------------------------------|
| **Швидкість**         | Швидше для операцій `add`, `remove`, `contains` (O(1)). | Повільніше (O(log n)).           |
| **Порядок елементів** | Не підтримує порядок.            | Зберігає порядок сортування.     |
| **Додаткові вимоги**  | Потребує коректного `hashCode()` та `equals()`. | Вимагає `Comparable` або `Comparator`. |
| **Пам’ять**           | Використовує більше пам'яті (для хеш-таблиці). | Менше пам'яті, але більше витрат на обчислення. |

---

## 8. **Чим поняття `size` відрізняється від `capacity`?**

1. **`size`:**
   - Кількість елементів, які фактично містяться в колекції.
   - Наприклад, у `HashSet` це кількість унікальних елементів.

2. **`capacity`:**
   - Максимальна кількість елементів, яку колекція може вмістити без збільшення розміру.
   - Зазвичай використовується у структурах із динамічним розміром, наприклад, у `ArrayList`.

### **Чи може `size` бути більшим за `capacity`?**
- **Ні**, це неможливо. `size` завжди менше або дорівнює `capacity`.

### **Чи може `capacity` бути більшим за `size`?**
- **Так**, зазвичай це відбувається:
  - Після створення колекції (початкова ємність більша за поточний розмір).
  - Після видалення елементів (залишається невикористана ємність).

---

## **Приклади:**

1. **`ArrayList`:**
   ```java
   ArrayList<Integer> list = new ArrayList<>(10); // Початкова capacity = 10
   list.add(1); // size = 1, capacity = 10
   ```

2. **`HashSet`:**
   - Початкова ємність хеш-таблиці може бути більшою за кількість елементів, щоб уникнути колізій.
   - Наприклад, `HashSet` із 16 бакетами може містити 10 елементів (`size = 10`, `capacity = 16`).

   # Java Collections: Відповіді на поширені запитання

## 9. **Що таке `load factor` та на що і як він впливає?**

- **`Load factor`** (коефіцієнт завантаження) — це міра заповненості хеш-таблиці, яка вказує, коли необхідно збільшити її розмір.
  
### **Як це працює:**
- Формула:  
  ```
  load factor = (size / capacity)
  ```
  де `size` — кількість елементів, а `capacity` — розмір хеш-таблиці (кількість бакетів).

- **Вплив:**
  - Якщо `load factor` перевищує встановлене значення (за замовчуванням 0.75 у `HashMap` і `HashSet`), хеш-таблиця збільшується в розмірі (ресайзинг).
  - Ресайзинг подвоює кількість бакетів і перехешує всі елементи.

- **Переваги/недоліки:**
  - Менший `load factor` → менше колізій, але більше пам'яті.
  - Більший `load factor` → економія пам'яті, але більше колізій.

---

## 10. **Що таке асоціативний масив? Чим ключ відрізняється від значення?**

- **Асоціативний масив** (або мапа) — це структура даних, яка зберігає пари ключ-значення, де кожен ключ пов'язаний із певним значенням.  
  У Java це реалізовано через інтерфейс `Map`.

### **Ключ і значення:**
- **Ключ (key):**
  - Використовується для унікальної ідентифікації пари.
  - Ключі в `Map` є унікальними (дублювання не допускається).
- **Значення (value):**
  - Дані, які асоціюються з ключем.
  - Значення можуть дублюватися.

---

## 11. **Чи може в асоціативному масиві зберігатись кілька однакових ключів або значень?**

- **Ключі:**  
  Ні, ключі в `Map` мають бути унікальними. При додаванні нового значення із тим самим ключем старе значення буде замінене.
  
- **Значення:**  
  Так, значення можуть повторюватися. Наприклад, кілька різних ключів можуть мати однакові значення.

---

## 12. **До яких наслідків може призвести зберігання неімутабельних об’єктів у `HashSet`, `HashMap`?**

### **У `HashSet`:**
- Якщо об'єкт, збережений у `HashSet`, змінить свої поля, які впливають на результат `hashCode()` або `equals()`, хеш-таблиця більше не зможе коректно знайти або видалити цей об'єкт.
  
### **У `HashMap` як ключ:**
- Ключі у `HashMap` також залежать від `hashCode()` і `equals()`.  
  Якщо ключ зміниться після вставки, він більше не буде знайдений у мапі, що може призвести до втрати доступу до відповідного значення.

### **У `HashMap` як значення:**
- Зміни у значеннях не впливають на коректність роботи `HashMap`, оскільки пошук здійснюється за ключем.

---

## 13. **Чи можуть об’єкти без інтерфейсу `Comparable` зберігатись у `TreeMap`?**

- Ні, об'єкти без інтерфейсу `Comparable` не можуть бути ключами у `TreeMap`, якщо ви не передали кастомний `Comparator` у конструктор.
  
### **Чому?**
- `TreeMap` використовує порядок сортування для організації ключів, і без реалізації `Comparable` або надання `Comparator` він не знає, як порівнювати об'єкти.

---

## 14. **Чи можуть об’єкти без інтерфейсу `Comparable` зберігатись у `HashMap`?**

- Так, об'єкти без інтерфейсу `Comparable` можуть бути ключами або значеннями у `HashMap`.  
  `HashMap` не залежить від сортування, тому наявність чи відсутність `Comparable` не має значення.

### **Чи впливає наявність `Comparable` на `HashMap`?**
- Ні, `Comparable` не впливає на роботу `HashMap`, оскільки `HashMap` використовує лише `hashCode()` і `equals()` для порівняння ключів.

---

## Порівняння `HashSet` та `TreeSet`:
| **Критерій**            | **HashSet**                 | **TreeSet**                      |
|-------------------------|-----------------------------|-----------------------------------|
| **Порядок елементів**   | Не гарантує жодного порядку | Елементи сортуються              |
| **Швидкість**           | Швидший (O(1))             | Повільніший (O(log n))           |
| **Додаткові вимоги**    | Реалізація `hashCode()` та `equals()` | Реалізація `Comparable` або `Comparator` |

--- 

## **Поняття `size` і `capacity`:**
- **`size`:** Кількість елементів у колекції.
- **`capacity`:** Максимальна кількість елементів, яку колекція може зберігати без збільшення розміру.

| Ситуація                                   | Можливість                |
|-------------------------------------------|---------------------------|
| **`size > capacity`**                     | Неможливо                 |
| **`capacity > size`**                     | Можливо (зазвичай завжди) |

---